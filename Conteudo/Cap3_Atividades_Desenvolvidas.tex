\chapter{Atividades Desenvolvidas}\label{sec:ativ_desenvolvidas}
Nesta seção, é apresentada, em detalhes, cada uma das principais atividades realizadas para a condução deste projeto.

\section{Estudo sobre Aprendizagem móvel}\label{sec:estudos_ap_movel} 
Existem várias definições de \textit{m-learning}. Ao longo dos anos, pesquisadores se dispuseram a estudar o assunto e tentaram achar uma definição. De acordo com \cite{Quinn2000}, \textit{m-learning} é um modelo de aprendizagem eletrônica (\textit{e-learning}) que utiliza equipamentos computadorizados: \textit{Palmtops}, dispositivos que rodam Windows Embedded Compact e até um telefone celular.
Em 2011, \cite{hwang2011research} disseram que uma definição amplamente aceita de \textit{m-learning} é simplesmente ``usar tecnologias móveis para facilitar o aprendizado''. Dentre outras definições, a adotada para esse projeto foi a seguinte: qualquer fornecimento educacional onde a tecnologia dominante é portátil ou dispositivos \textit{palmtop} \citep{traxler2005defining}.

Todavia, independente da definição tomada, torna-se necessário analisar vantagens e desvantagens de utilizar dispositivos móveis. De acordo com \cite{RICHAMEHTA2016} destacam-se como vantagens: (i) PDAs ou tablets com anotações e e-books são mais leves e menos volumosos que mochilas cheias de papéis, livros e até laptops; (ii) É mais fácil acomodar dispositivos móveis em uma sala se comparado à computadores de mesa; (iii) Dispositivos móveis podem ser usados em qualquer lugar e em qualquer momento, como em trens, em casa, em hotéis. Isto tem um valor inestimável para a educação \citep{CarmaMaia2008}.

De acordo com \cite{RICHAMEHTA2016}, destacam-se as seguintes desvantagens: (i) Celulares pequenos e telas de PDAs limitam-se a quantidade e tipo de informação que pode ser exibida; (ii) Baterias precisam ser recarregadas regularmente, e dados podem ser perdidos caso não se faça o carregamento correto; (iii) É difícil usar gráficos que possuem movimento, especialmente em celulares pequenos.

Devido ao processo de envelhecimento, limitações e desafios podem ser potencializadas no caso de usuários idosos, visto que podem ocorrer mudanças para o idoso durante esse processo. Além disso, é necessário que as aplicações educacionais móveis levem em consideração propostas pedagógicas adequadas e específicas para esse público. Desse modo, é indispensável que o desenvolvimento dessas aplicações seja realizado de maneira clara e objetiva, possibilitando melhor aprendizagem por parte do idoso.

\section{Levantamento e estudo dos conceitos e tecnologias para desenvolvimento de aplicações móveis}

Nesta seção serão abordados os principais conceitos relacionados ao desenvolvimento de aplicações móveis. Desse modo, os principais temas foram: (i) estudo sobre Scrum e Requisitos que trata sobre a metodologia de desenvolvimento adotada neste projeto; (ii) estudos sobre React Native que contempla o levantamento e pesquisa da tecnologia adotada para concepção do sistema; (iii) por fim, estudos sobre UI/UX que discute o conhecimento relacionado a interface e experiência do usuário.

\subsubsection{Estudos sobre Scrum e Requisitos} 
Em 2001, um grupo de 17 pessoas se reuniu para discutir a respeito de desenvolvimentos mais leves de software, pois acreditavam que os modelos em voga eram lentos e burocráticos. O resultado foi o Manifesto Ágil \citep{agileManifesto}, em que os participantes propuseram princípios a serem seguidos. Segundo os criadores, deveria haver a valorização de: (i) Indivíduos e interações mais que processos e ferramentas; (ii) Software em funcionamento mais que documentação abrangente; (iii) Colaboração com o cliente mais que negociação de contratos; (iv) Responder a mudanças mais que seguir um plano.

Dentre os artefatos do \textit{Scrum}, devem ser citados o \textit{Product Backlog} e o \textit{Sprint Backlog}. O \textit{Product Backlog} possui todas as funcionalidades necessárias para o funcionamento do produto, as quais são ordenadas por prioridade. Já o \textit{Sprint Backlog} reúne as funcionalidades que serão desenvolvidas na atual \textit{Sprint} em execução.

Os eventos do Scrum são: (i) Sprint; (ii) Reunião de Planejamento da Sprint; (iii) Reunião Diária; (iv) Revisão da Sprint; (v) Retrospectiva da Sprint.

A \textbf{\textit{Sprint}} é essencial para o Scrum, durante um período de 2 a 4 semanas são desenvolvidas as atividades do \textit{Sprint Backlog}, as quais foram previamente selecionadas do \textit{Product Backlog}. Estas atividades são escolhidas na \textbf{Reunião de planejamento da \textit{Sprint}}. É importante destacar que concomitantemente à Sprint são realizadas \textbf{Reuniões diárias}, que possuem o objetivo de reunir o time de desenvolvimento a fim de sincronizar as atividades e criar um plano para as próximas 24 horas. Ao final do período separado para o incremento do produto, ocorre a \textbf{Revisão da Sprint}, com o objetivo de discutir o que foi feito, inspecionar o incremento e adaptar o \textit{Product Backlog}. A \textbf{Retrospectiva da Sprint} ocorre depois da Revisão da Sprint e antes da Reunião de planejamento da próxima Sprint, e é a oportunidade para o Time Scrum inspecionar a si próprio criar um plano para melhorias a serem aplicadas na próxima Sprint.

Ademais, existem funções diferentes para os membros chamadas de papéis. São eles: \textit{Product Owner}; Time de Desenvolvimento e \textit{Scrum Master}. 
O \textit{Product Owner}, ou dono do produto, se encarrega de maximizar o valor do produto e gerenciar os \textit{Backlogs}. O Time de Desenvolvimento concentra os profissionais responsáveis pelos incrementos do produto. Por fim, o \textit{Scrum Master} orquestra toda a equipe e deve garantir que o Scrum seja entendido e aplicado.

Outro fator importante para o desenvolvimento de um software são os requisitos. De acordo com \cite{Sommervile2010}, eles podem ser definidos como os serviços que o sistema promove, as restrições de operação e as descrições do que o sistema deveria realizar. É importante destacar a Engenharia de Requisitos, a qual fornece mecanismos apropriados para o entendimento da demanda do consumidor, análise de suas necessidades, avaliação da viabilidade, negociação de uma solução, especificação de uma solução não ambígua, validação da especificação e gerenciamento de requisitos enquanto são transformados em um sistema operacional \citep{Pressman2014}. 

Três são os principais tipos de requisitos \citep{Sommervile2010}:
\begin{itemize}
    \item \textbf{Requisitos funcionais}: são declarações de serviços que o sistema deve prover, como o sistema deve reagir a determinados tipos de entrada, e como deveria funcionar em situações particulares. Em alguns casos, os requisitos funcionais podem também explicitar o que o sistema não deveria fazer.
    
    \item \textbf{Requisitos não funcionais}: são restrições dos serviços ou funções oferecidos pelo produto. Incluem restrições de tempo, de processos de desenvolvimento, e restrições impostas por padrões. Requisitos não funcionais frequentemente se aplicam ao sistema como um todo, em vez de se aplicar a serviços ou \textit{features} individuais.
    
    \item \textbf{Requisitos de domínio}: são derivados do domínio de aplicação do sistema, e não de necessidades específicas de usuários do sistema. Podem ser novos requisitos funcionais, restringindo os já existentes. 
\end{itemize}


\subsection{Estudos sobre React Native} 
São diversas as maneiras de desenvolver um aplicativo móvel. A maneira convencional é utilizar a linguagem nativa: Java (Android) e Swift/Object-C (iOS), todavia isso causa o empecilho de se disponibilizar o aplicativo apenas para uma plataforma. Ainda, é possível usar \textit{frameworks} híbridos que recorrem ao uso de \textit{web-views} para renderizar a aplicação e disponibilizar para os dois sistemas operacionais, pode-se citar Ionic, Titanium, e PhoneGap. Entretanto, o desempenho de aplicativos construídos com tais tecnologias é precário. Pensando no problema, durante a conferência do React.js em 2015, o Facebook introduziu seu novo \textit{framework} React Native, o qual prometia revolucionar a maneira de desenvolver aplicativos móveis. A premissa era simples, possibilitar o desenvolvimento \textit{mobile} sem a necessidade de programação diferente para os dois sistemas operacionais líderes.

% Vantagens e desvantagens
As principais vantagens do uso do React Native, de acordo com \cite{danielsson2016}, são: (i) O desenvolvimento ocorre em uma única linguagem, sendo possível utilizar o aplicativo em iOS ou Android; (ii) A documentação oficial dá grande suporte de ajuda; (iii) O React Native não possui nenhum efeito negativo na experiência do usuário, pois a diferença de desempenho é imperceptível para a grande maioria dos usuários.

Dentre as desvantagens, é importante destacar: (i) Incerteza da possibilidade de executar frequentes tarefas em segundo plano quando o aplicativo já está sendo executado em segundo plano \citep{sodebergJohansson}; (ii) Testes concluem que a frequência GPU, carregamento de CPU, uso de memória e consumo de energia são levemente inferiores ao desenvolvimento nativo \citep{danielsson2016}.

Entretanto, embora existam algumas desvantagens do uso do React Native, em termos gerais é uma excelente alternativa para o projeto, pois não compromete de maneira significante a performance do aplicativo e possibilita o uso nas plataformas iOS e Android, alcançando assim, um número maior de usuários.

\subsection{Estudos sobre UI/UX}
A Interface de Usuário (UI) se refere a um sistema e um usuário interagindo um com outro por meio de comandos para operar o sistema, inserir dados, e usar o conteúdo \citep{joo2015}. Já a Experiência de Usuário (UX), segundo \cite{marc2008}, é uma perspectiva distinta da qualidade de tecnologia interativa. O autor ainda define UX como uma avaliação momentânea e primária da sensação (bom-ruim) enquanto interage com o produto ou serviço. Dessa forma, UX troca a atenção dos produtos e materiais para as sensações humanas - o lado subjetivo do uso do produto. Ainda, de acordo com \cite{castilla2017}, a UX representa uma mudança do próprio conceito de usabilidade, pois o objetivo não se reduz a melhorar a sensação do usuário na eficácia, eficiência e facilidade de aprendizagem, mas sim tentar resolver o problema estratégico da utilidade do produto para o usuário. 

Dessa maneira, pode-se concluir que a interface e experiência do usuário cumprem papéis essenciais no desenvolvimento de um produto, sendo indispensável seu planejamento. Ainda, tendo em vista o público alvo do atual projeto, usuários idosos, torna-se necessária a atenção e cuidado no assunto a fim de alcançar os objetivos finais.

Portanto, tendo em mente os motivos acima citados, foi realizado um minicurso sobre a Experiência de usuário e Interface de usuário com uma especialista da área UI/UX cujo título era ``Como incluir UX e UI Design nos seus projetos''. A realização se deu na 22ª Semana da Computação da Universidade de São Paulo, campus de São Carlos, no dia 03/10. O minicurso se mostrou de grande importância, uma vez que possibilitou a expansão do conhecimento do assunto em termos práticos, sendo possível sua aplicação no projeto.

\section{Pesquisa sobre as principais funcionalidades de aplicativos de aprendizagem móvel} 
Diversos são os aplicativos que possuem o objetivo de apoiar o processo de ensino e aprendizagem do usuário; seja por meio de jogos, vídeos ou outros materiais. Dessa maneira, alguns aplicativos (para diferentes públicos) foram analisados, a fim de verificar suas funcionalidades e propostas de aprendizagem e acessibilidade, de maneira que essas pudessem ser adaptadas ou utilizadas para aplicações com foco no idoso.

\begin{description}
% Ensina o que? Qual o publico alvo? Pessoas de quantos anos?

\item[Engaging congress]\footnote{\url{https://play.google.com/store/apps/details?id=com.iu.engagingcongress&hl=en}, \url{https://apps.apple.com/us/app/engaging-congress/id1309161238?ls=1}} \hfill \\
\textit{Enganging congress} (\autoref{fig:EngCong}) é um jogo interativo que visa explorar os princípios básicos de um governo representativo. Escolhe-se um tema e é exibido um vídeo. Jogos são incluídos no processo baseados no tema. É importante destacar a atenção dos criadores em fazer o usuário compreender a tarefa; a todo momento é possível clicar no botão de dúvida. As principais funcionalidades são: (i) vídeos educativos sobre o tema; (ii) perguntas relacionadas ao conteúdo passado; (iii) nota final após a conclusão dos exercícios; (iv) botões de dúvidas sempre presentes.

\begin{figure}[ht!]
\centering
    \caption{Telas do aplicativo \textit{Engaging Congress}}
    \label{fig:EngCong}
    \includegraphics[width=0.9\textwidth]{Figuras/engagingcongress.png}
    
    Fonte: Elaborada pelo autor
\end{figure}

\item[Play PBS KIDS Games]\footnote{\url{https://apps.apple.com/us/app/pbs-kids-games/id1050773989}, \url{https://play.google.com/store/apps/details?id=org.pbskids.gamesapp&hl=pt_BR}} \hfill \\
O aplicativo (\autoref{fig:pbs}) visa a promoção da educação para crianças na fase de alfabetização (2 a 8 anos), pois contém mais de 100 mini-jogos voltados para tal. As crianças são encorajadas a resolver desafios e aprimorar suas habilidades em ciências, matemática, letras e criatividade. O objetivo é impactar positivamente as vidas de crianças por meio de mídia baseada em um currículo onde quer que elas estejam. O app ganhou duas premiações no ano de 2017, a saber Melhor aplicativo de jogos para Pré-Escola (\textit{Kidscreen Award Winner}) e o \textit{Parents' Choice Recommended Mobile App}. Os principais recursos são: (i) funcionamento offline; (ii) possibilidade de gerenciar a quantidade de memória que será consumida; (iii) obter detalhes sobre desenhos da TV PBS Kids como idade recomendada e objetivos de aprendizado para as crianças.

\begin{figure}[H]
\centering
    \caption{Telas do aplicativo \textit{Play PBS KIDS Games}}
    \label{fig:pbs}
    \includegraphics[width=0.9\textwidth]{Figuras/pbsKids.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

\item[Human Anatomy Atlas]\footnote{\url{https://apps.apple.com/br/app/human-anatomy-atlas-2020/id1117998129}, \url{https://play.google.com/store/apps/details?id=com.argosy.vbandroid&hl=pt_BR}} \hfill \\
O \textit{Human Anatomy Atlas} (\autoref{fig:humAtlas}) é um aplicativo criado por um time de especialistas em visualização biomédica. É direcionado ao ensino da anatomia do corpo humano com o foco em estudantes e professores, apesar de também ser utilizado em hospitais. Seus modelos em 3D promovem uma fidelidade às estruturas humanas reais, sendo possível rotacionar e dissecar órgãos e partes do corpo. Possui recursos como : (i) interatividade com estruturas 3D; (ii) mais de 1000 questões para testes em assuntos; (iii) visualização de anatomias complexas em realidade aumentada; (iv) disponibilidade em 7 idiomas.

\begin{figure}[ht!]
\centering
    \caption{Telas do aplicativo \textit{Human Anatomy Atlas}}
    \label{fig:humAtlas}
    \includegraphics[width=0.9\textwidth]{Figuras/humanAtlas.png}
    
    Fonte: \cite{HumanAnatomyAtlas}
\end{figure}

\item[Bini Super ABC]\footnote{\url{https://apps.apple.com/br/app/bini-abc-alfabeto-crianças-app/id1397966958}, \url{https://play.google.com/store/apps/details?id=com.binibambini.abc&hl=pt_BR}} \hfill \\
Bini Super ABC (\autoref{fig:biniABC}) é um aplicativo voltado para crianças na faixa de 3 a 5 anos na fase de instrução educacional. O aplicativo promove o aprendizado das letras do alfabeto com diversos jogos infantis. O objetivo é tornar o ensino interessante e empolgante com desenhos coloridos, personagens e efeitos sonoros. A aplicação possui as funcionalidades: (i) aprendizado das letras por sons; (ii) reforço do material aprendido; (iii) controle de responsáveis para os jogos.

\begin{figure}[H]
\centering
    \caption{Telas do aplicativo \textit{Bini Super ABC}}
    \label{fig:biniABC}
    \includegraphics[width=0.9\textwidth]{Figuras/biniabc.png}
    
    Fonte: Elaborada pelo autor
\end{figure}

\item[Crossword Puzzle Free]\footnote{\url{https://play.google.com/store/apps/details?id=mobi.redstonegames.crossword.en&hl=pt_BR}} \hfill \\
Crossword Puzzle Free (\autoref{fig:crossFree}) é um aplicativo de palavras cruzadas. É simples e fácil de usar não exigindo conhecimentos específicos do usuário. Com os 4 níveis de dificuldade é possível buscar o desafio na medida certa além de motivar o usuário a continuar utilizando o aplicativo por não ser nem muito fácil nem muito difícil. As principais funcionalidade são: (i) Teclado do próprio aplicativo; (ii) Dicas aparecem acima do teclado; (iii) Botão de dica para a palavra.


\begin{figure}[H]
\centering
    \caption{Telas do aplicativo \textit{Crossword Puzzle Free}}
    \label{fig:crossFree}
    \includegraphics[width=0.9\textwidth]{Figuras/crosswordPuzzleFree.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

\item[Crossword Quiz]\footnote{\url{https://play.google.com/store/apps/details?id=com.randomlogicgames.crossword&hl=pt_BR}} \hfill \\
Crossword Quiz (\autoref{fig:crossQuiz}) é um aplicativo de palavras cruzadas com uma abordagem mais fácil por não disponibilizar todas as letras do teclado, tornando a resposta mais fácil para o usuário. Além disso, o aplicativo não conta apenas com dicas escritas, mas inclui imagens. As funcionalidade que se destacam são: (i) Não mostrar todo o teclado, apenas algumas letras; (ii) Mostra imagens como dicas além de textos; (iii) Tutorial inicial intuitivo e completo.

\begin{figure}[H]
\centering
    \caption{Telas do aplicativo \textit{Crossword Quiz}}
    \label{fig:crossQuiz}
    \includegraphics[width=0.9\textwidth]{Figuras/crosswordQuiz.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

\end{description}



\begin{table}[!ht]
\caption{\textit{Funcionalidades das aplicações educacionais}}
\centering
\footnotesize
\begin{tabular}{p{6cm} p{12cm}}
\toprule
\textbf{Aplicativo} & \textbf{Funcionalidades}                                              \\ \midrule

Engaging congress   & \begin{tabular}[c]{@{}l@{}}Vídeos educativos\\ Perguntas relacionadas ao conteúdo\\ Nota após término dos exercícios\\ Botões de dúvida em todas as telas\end{tabular}                                                                 \\ \midrule
Play PBS KIDS Games & \begin{tabular}[c]{@{}l@{}}Funcionamento offline\\ Gerenciamento de consumo de memória\\ Obtenção de detalhes de desenhos passados na TV PBS Kids\end{tabular}      \\ \midrule
Human Anatomy Atlas & \begin{tabular}[c]{@{}l@{}}Interatividade com estruturas 3D\\ Mais de 1000 questões para testes\\ Realidade aumentada\\ Sete idiomas disponíveis\end{tabular}    \\ \midrule
Bini Super ABC & \begin{tabular}[c]{@{}l@{}}Aprendizado das letras por sons\\ Reforço do material aprendido\\ Controle de responsáveis para jogos\end{tabular}                \\ \midrule
Crossword Puzzle Free & \begin{tabular}[c]{@{}l@{}}Teclado próprio\\ Dica acima do teclado\\ Botão de dica para a palavra\end{tabular}                \\ \midrule
Crossword Quiz & \begin{tabular}[c]{@{}l@{}}Não mostra o teclado todo, apenas algumas letras\\ Mostra imagens em vez de dicas em texto também\\ Tutorial inicial mostrando todos os passos antes de mesmo de permitir o jogador jogar uma partida sozinho\end{tabular}                \\ \midrule
\end{tabular}
\label{tab:sprint}
\end{table}



\section{Estudo do algoritmo de geração das palavras cruzadas} 
Nesta seção será abordado o algoritmo de geração das palavras cruzadas do aplicativo. Para melhor compreensão deste, é essencial a noção dos paradigmas clássicos da Ciência da Computação: Força Bruta e \textit{Backtracking}. Além disso, faz-se necessário uma pequena noção das Cadeias de Markov Absorventes para estipulação e análise do tempo de execução do algoritmo até que se encontre uma solução. Por fim, utilizando os conceitos anteriormente explanados, será possível compreender o motivo do algoritmo possuir um bom desempenho.

\subsection{Força Bruta e \textit{Backtracking}}
A Força Bruta é um paradigma de programação em que o espaço de busca é vasculhado sistematicamente até que se encontre a solução desejada. Um exemplo clássico é a tentativa de descobrir uma senha numérica de 5 dígitos. A abordagem por Força Bruta faria a tentativa de todas as $10^{5}$ possibilidades ($00000 \rightarrow 00001 \rightarrow 00002 \rightarrow 00003$...) até que se encontre a combinação correta da senha. Em geral, as abordagens por força bruta não são eficientes em termos de complexidade de tempo, como se poderá constatar no algoritmo de geração de palavras cruzadas.

Já o \textit{Backtracking} é também um paradigma de programação largamente estudado nos cursos de Ciência da Computação. Segundo \cite{nilsson1980principles}, o \textit{Backtracking} é um método de resolução de problemas de Ciência da Computação em que se estende incrementalmente uma solução parcial que especifica valores consistentes para uma das variáveis, em direção a uma solução completa, ao repetidamente escolher um valor para outra variável consistente com os valores da atual solução parcial. Pode-se dizer que \textit{Backtracking} é uma extensão da busca por Força Bruta, em que há restrições que devem ser satisfeitas. Estas, podem ser avaliadas antes que todas as soluções tenham sido geradas e dessa maneira possíveis soluções podem ser descartadas antes de finalizadas. Ao se fazer a árvore de possibilidades com o algoritmo de Força Bruta, o \textit{Backtracking} seria responsável pela ``poda'' dos ramos da árvore em que não há possibilidade de solução.

% Se der tempo, colocar um exemplo de backtracking com figuras e com a arvore

\subsection{Cadeias de \textit{Markov}}
Antes da definição das Cadeias de Markov é necessário compreender o que são Modelos Estocásticos. De acordo com \cite{howard1998introduction}, um modelo matemático é uma descrição quantitativa de um fenômeno natural. Assim, é possível definir um modelo determinístico como aquele que prediz um único resultado de um conjunto de circunstâncias. Já um modelo estocástico, prediz um conjunto de possíveis resultados ponderados por suas probabilidades ou possibilidades \citep{howard1998introduction}. Assim, define-se Cadeias de Markov como um Processo de Markov com a seguinte propriedade: qualquer comportamento futuro do processo, quando seu estado atual é conhecido com exatidão, não é alterado por nenhum conhecimento adicional em relação aos comportamentos passados \citep{howard1998introduction}. Caso a cadeia possua no mínimo um estado final de absorção em que seja possível chegar, é chamada Cadeia de Markov Absorvente; uma vez que se entra em um estado de absorção não é mais possível sair. 

% Colocar uma figura

% Explicar primeiro processos deterministicos e processos estocasticos
% Depois cadeias de markov, depois com absorção
% Depois as matrizes de transição (só colocar depois de acabar tudo)
% Depois explicar como se calcula o tempo médio até a absorção (só colocar depois de acabar tudo)

\subsection{Desenvolvimento do algoritmo}
O algoritmo utilizado é intitulado \textit{Wizium} \citep{wizium}, a seguir serão expostos os passos que levaram a seu desenvolvimento, de acordo com o autor, e as análises matemáticas para a compreensão de sua efetividade.

A primeira abordagem para a solução do problema seria simplesmente utilizar o paradigma da Força Bruta. Para os exemplos serão utilizados tabuleiros que somente possuam palavras, a fim de simplificar a compreensão. Seja um tabuleiro $3x3$ com as seguintes palavras: \textbf{ASA}, \textbf{SAL}, \textbf{ALA} e \textbf{CEU}. Assim, basta escolher uma palavra das três listadas e colocá-la na primeira linha horizontal, escolher a próxima e colocá-la na segunda posição e depois na terceira. Dessa forma, é possível verificar se o tabuleiro totalmente preenchido é válido analisando as posições verticais. Se todas as palavras verticais estiverem no banco de palavras, o tabuleiro é válido, caso contrário, inválido. 

\begin{figure}[H]
\centering
    \caption{Árvore de tentativas utilizando Força Bruta}
    \label{fig:crossTree}
    \includegraphics[width=0.9\textwidth]{Figuras/crosswordsTree.png}
    
    Fonte: Elaborada pelo autor
\end{figure}

Como pode-se perceber, a análise só é feita após o último passo. Algumas ramificações da árvore de tentativas poderiam ter sido ``podadas'' com uma análise prévia do tabuleiro antes que chegasse em seu estado completo, ou seja, diversas tentativas poderiam ter sido evitadas. 
Para uma melhor noção da inviabilidade de tal abordagem é possível contar a quantidade de tabuleiros possíveis por meio de combinações e permutações.
Se $B$ é o tamanho do tabuleiro e $A$ é a quantidade palavras de tamanho $B$ disponíveis no banco de palavras, a quantidade de tabuleiros possíveis pode ser calculada com a seguinte fórmula: 
\begin{center}
\Large{$N_{t} =$ $A \choose{B}$$*B!$} 
\label{qtdtab}
\end{center}

Em que $A \choose{B}$ determina a quantidade de grupos de B palavras de tamanho B e $B!$ determina a quantidade de permutações dessas palavras no tabuleiro. Utilizando um banco de palavras da Língua Portuguesa obteve-se a seguinte distribuição de tamanhos:

% https://online.visual-paradigm.com/app/diagrams/#proj=0&type=BarChart (site)
\begin{figure}[H]
\centering
    \caption{Distribuição das palavras por tamanho}
    \label{fig:distTam}
    \includegraphics[width=0.9\textwidth]{Figuras/distribuicaoPorTamanho.png}
    
    Fonte: Elaborada pelo autor
\end{figure}

Além disso, pode-se analisar as probabilidades de um tabuleiro estar correto dado o tamanho e quantidade de palavras no banco. Primeiramente, será calculada a frequência das letras no banco de palavras como mostrado na Figura \ref{fig:freqPal}:

\begin{figure}[H]
\centering
    \caption{Frequência das letras no banco de palavras}
    \label{fig:freqPal}
    \includegraphics[width=0.9\textwidth]{Figuras/frequenciaLetras.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

Em seguido, será calculada a probabilidade de coincidência de duas letras ($p_{co}$), em que $l$ corresponde a $l^{esima}$ letra do alfabeto e $f(l)$ corresponde a frequência que a letra aparece em uma palavra qualquer:

\begin{center}
\Large{$p_{co} = \sum_{l=1}^{26}f(l)^{2}$}
\label{pco}
\end{center}

% A princípio não trataremos as probabilidades para o caso de força bruta. Caso se queira usar, utilize a seguinte tabela comentaeda no lugar da atual
% \begin{table}[!ht]
% \caption{\textit{Tabuleiros gerados por Força Bruta}}
% \centering
% \footnotesize
% \begin{tabular}{|c|c|c|c|}
% \toprule
% \textbf{A} & \textbf{B} & \textbf{Número de tabuleiros} & \textbf{Probabilidade de um tabuleiro estar correto} \\ \hline
% 11140      & 5          & 1,7e+20 & pg                      \\ \hline
% 20172      & 6          & 6,7e+25 & pg                      \\ \hline
% 29051      & 7          & 1,7e+31 & pg                      \\ \hline
% 36722      & 8          & 3,3e+36 & pg                      \\ \hline
% 40547      & 9          & 2,9e+41 & pg                      \\ \hline
% \end{tabular}
% \label{tab:tabForBru}
% \end{table}

% Só fale das formulas no plural se realmente for usar a de probabilidade
Assim, é possível obter probabilidade de coincidência de uma letra $p_{co}$ valendo \textbf{7,6\%}. Uma vez calculado $p_{co}$, será calculada a probabilidade $p_{v}$ de uma palavra vertical de tamanho $B$ ser favorável, dado que existem $A$ palavras de tamanho $B$ no banco de palavras. 

\begin{center}
    \Large{$p_{v} = 1 - (1 - p_{co}^{B})^{A}$}
\end{center}

E assim calcula-se a probabilidade $p_{g}$ de todo o tabuleiro ser favorável.

\begin{center}
    \Large{$p_{g} = p_{v}^{B}$}
\end{center}

Logo, utilizando as fórmulas acima descritas, é possível obter a seguinte tabela:

% \begin{table}[!ht]
% \caption{\textit{Tabuleiros gerados por Força Bruta}}
% \centering
% \footnotesize
% \begin{tabular}{|c|c|c|}
% \toprule
% \textbf{A} & \textbf{B} & \textbf{Número de tabuleiros} \\ \hline
% 11140      & 5          & 1,7e+20  \\ \hline
% 20172      & 6          & 6,7e+25  \\ \hline
% 29051      & 7          & 1,7e+31  \\ \hline
% 36722      & 8          & 3,3e+36  \\ \hline
% 40547      & 9          & 2,9e+41  \\ \hline
% \end{tabular}
% \label{tab:tabForBru}
% \end{table}

\begin{table}[!ht]
\caption{\textit{Tabuleiros gerados por Força Bruta}}
\centering
\footnotesize
\begin{tabular}{|c|c|c|c|}
\toprule
\textbf{A} & \textbf{B} & \textbf{Número de tabuleiros ($N_{t}$)} & \textbf{Probabilidade de um tabuleiro estar correto ($p_{g}$)} \\ \hline
11140      & 5          & 1,7e+20 & $1,7*10^{-8}$                      \\ \hline
20172      & 6          & 6,7e+25 & $3,4*10^{-15}$                      \\ \hline
29051      & 7          & 1,7e+31 & aproximadamente 0                      \\ \hline
36722      & 8          & 3,3e+36 & aproximadamente 0                      
\end{tabular}
\label{tab:tabForBru}
\end{table}

% Se der tempo, colocar aqui a análise das fórmulas de probabilidade com o quadro de tempo, mas a principio nao faremos isso para a força bruta, como escrito acima

Portanto, faz-se necessária uma abordagem mais elaborada a fim de obter um melhor desempenho evitando comparações inúteis. Em uma primeira tentativa é possível tentar um \textbf{entrelaçamento}, colocando-se palavras na horizontal de cima para baixo e na vertical da esquerda para a direita. Ao se tentar incluir no tabuleiro, deverá ser feita uma verificação a fim de encontrar uma palavra com o prefixo determinado pela linha ou coluna, como se pode observar na Figura \ref{fig:entrelacamento}. 

\begin{figure}[H] 
\centering
    \caption{Inserção de palavras por entrelaçamento}
    \label{fig:entrelacamento}
    \includegraphics[width=0.9\textwidth]{Figuras/entrelacamento.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

Dessa maneira, será possível eliminar o quanto antes ramificações que não poderão gerar uma solução para o problema, assim que tal evento ocorrer bastará voltar um passo (\textit{Backtracking}) e tentar outra palavra. No exemplo dado, não há palavras de 5 letras com prefixo \textbf{IDR}.


Utilizando os conhecimentos das Cadeias de Markov explanados anteriormente, será a feita a modelagem do problema como um Processo Estocástico. Como está sendo utilizada a aproximação da probabilidade de coincidência de letras para palavras quaisquer ($p_{co}$ \ref{pco}), é conveniente aproximar cada estado do Processo como a tentativa de inserção de uma palavra na horizontal ou vertical. Haverão as possibilidades de sucesso ou falha do processo; caso seja possível inserir uma palavra ocorrerá o avanço, caso contrário, o retrocesso ao estado anterior utilizando-se o \textit{Bactracking}. 

Seja N a quantidade de palavras de tamanho S no banco de palavras, $wh_{i}$ e $wv_{i}$ as S células horizontais e verticais, respectivamente. A probabilidade de que seja possível a inserção em uma palavra na posição $i$ é dada por:

\begin{center}
    \Large{$p_{hi} = 1 - (1 - p_{co}^{i})^{N}$}
    
    \Large{$p_{vi} = 1 - (1 - p_{co}^{i+1})^{N}$}
\end{center}

Onde $i = 0...S-1$. De maneira mais clara, são as probabilidades de uma palavra inserida na vertical ou horizontal tenha a coincidência de letras até a posição $i$. Portanto, a modelagem do problema se reflete na seguinte Cadeia de Markov:

\begin{figure}[H]
\centering
    \caption{Cadeia de Markov para entrelaçamento}
    \label{fig:markov1}
    \includegraphics[width=0.9\textwidth]{Figuras/markovChain1.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

% Decidir se vai colocar o passo a passo ou mesmo a tabela (isso abaixo) no relatorio
% Utilizando-se os conceitos de tempo médio para o estado de absorção expostos anteriormente, é possível calcular a quantidade de passos média do algoritmo de \textit{Bactracking} até que se chegue em uma solução.

% Colocar tabela de passos (e talvez) com o tempo de execução em segundos, minutos, etc

Todavia, ainda é possível aumentar a eficiência do algoritmo antecipando ainda mais os ramos da árvore de tentativas que não poderão gerar uma solução. O algoritmo anterior verifica a possibilidade de inserção de uma palavra examinando até a posição $i$, não considerando com antecedência impossibilidades das linhas ou colunas , como na Figura \ref{fig:scaffolding}, que tem a última coluna sendo iniciada com \textbf{SR} (palavras de 5 letras iniciadas com \textbf{SR} são inexistentes no banco de palavras usado). Dessa maneira, diversos passos ainda são executados mesmo com uma formação impossível de tabuleiro, desperdiçando tentativas e tempo de computação.


% Colocar aqui aquele que só da PS na ultima vertical
\begin{figure}[H]
\centering
    \caption{O algoritmo só detectaria a impossibilidade da última coluna no último passo}
    \label{fig:scaffolding}
    \includegraphics[width=0.9\textwidth]{Figuras/bradingerror.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

Logo, verificar a possibilidade de inserir palavras na vertical nas S posições solucionaria o problema acima descrito, pois anteciparia ainda mais os ramos da árvore sem solução. A nova abordagem consiste em inserir uma palavra na horizontal, se e somente se, houverem prefixos compatíveis cujas palavras possam ser inseridas em cada uma das posições verticais.

\begin{figure}[H]
\centering
    \caption{Verificando cada posição vertical}
    \label{fig:scaffoldingcool}
    \includegraphics[width=0.9\textwidth]{Figuras/scaffoldingcool.jpg}
    
    Fonte: Elaborada pelo autor
\end{figure}

No exemplo acima, \textbf{adega} não pode ser inserida pois não existe uma palavra de 5 letras iniciada por \textbf{ADD}.
Ainda, uma vez que só serão inseridas palavras na horizontal e não na vertical, a Cadeia de Markov do Processo terá metade de seu tamanho, já que a quantidade de inserções muda de $2S$ para $S$.

% Obs.: Em vez de retornar o número médio de palavras de tam S com prefixo i; eu nao deveria retornar o quantidade total de palavras com tamanho maior ou igual a i?
Seja $M(S,i)$ a função que retorna o número médio de palavras de tamanho $S$ que possuem prefixo de tamanho $i$. Portanto, é possível definir a probabilidade de existir uma palavra que possa ser inserida na vertical ao se colocar uma letra na posição $i$; só é necessário verificar a última letra pois as $i-1$ letras anteriores já foram testadas previamente.

\begin{center}
    \Large{$p_{co_{i}} = M(S,i)*p_{co}$}
\end{center}

Logo, a probabilidade de uma palavra poder ser inserida na horizontal na linha $i$ é dada por:

\begin{center}
    \Large{$p_{h_{i}} = N*(p_{co_{i}})^{S}$}
\end{center}

% Já decidiu se vai colocar isso mesmo?
% Dessa forma, é possível criar uma nova tabela com a quantidade de passos necessários para preencher o tabuleiro com uma solução.

% Não seria uma tabela com a quantidade de grids que conseguiríamos formar??? acho q sim ein, confere aí depois

% Fazer as contas e preencher a tabela